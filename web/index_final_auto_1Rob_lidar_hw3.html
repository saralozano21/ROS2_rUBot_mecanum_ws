<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ROS Web Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/roslib@1/build/roslib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  <style>
    :root{
      --gap: 20px;
      --card-bg: #fff;
      --card-bd: #ccc;
      --page-bg: #414141;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--page-bg);
      color: #e6e6e6;
    }

    .connection-form {
      width: 100%;
      margin-bottom: var(--gap);
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    .connection-form label { color: #fff; }
    .connection-form input[type="number"]{
      width: 70px;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #bbb;
      background: #fff;
    }
    .connection-form button{
      padding: 8px 14px;
      border-radius: 6px;
      border: 1px solid #bbb;
      background: #f5f5f5;
      cursor: pointer;
    }
    .connection-form button:hover { filter: brightness(0.97); }
    .connection-form button.connected {
      background: #2ecc71;
      border-color: #2ecc71;
      color: #fff;
    }

    .dashboard {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-areas:
        "camera right"
        "map    pos";
      align-items: center;
      justify-items: center;
      gap: var(--gap);
    }

    #camera-feed      { grid-area: camera; }
    .right-panel      { grid-area: right; }
    .map-display      { grid-area: map; }
    .position-display { grid-area: pos; }

    .right-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .joy-legend {
      font-size: 1rem;
      font-weight: 700;
      color: #eee;
      text-align: center;
      margin-top: 0;
    }

    .joystick-container {
      width: 200px;
      height: 200px;
      background-color: #ddd;
      border-radius: 50%;
      position: relative;
      overflow: hidden;
      touch-action: none;
    }

    .joy-vel {
      font-size: 0.9rem;
      color: #ddd;
      text-align: center;
    }

    .omega-wrap {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      color: #eee;
      font-size: 0.95rem;
      width: 100%;
      margin-top: 4px;
    }

    #omegaSlider {
      -webkit-appearance: none;
      appearance: none;
      width: 160px;
      height: 10px;
      border-radius: 6px;
      background: #666;
      outline: none;
    }
    #omegaSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #f5f5f5;
      border: 2px solid #222;
      cursor: pointer;
    }
    #omegaSlider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #f5f5f5;
      border: 2px solid #222;
      cursor: pointer;
    }

    .map-display { width: min(280px, 100%); }

    .image-view {
      width: 360px;
      height: 270px;
      background-color: #000;
      border-radius: 5px;
      border: 1px solid var(--card-bd);
      object-fit: cover;
      display: block;
    }

    .map-image {
      width: 100%;
      height: auto;
      border: 1px solid var(--card-bd);
      border-radius: 5px;
      display: block;
      background-color: #e6e6e6;
    }

    @media (max-width: 900px) {
      .dashboard {
        grid-template-columns: 1fr;
        grid-template-areas:
          "camera"
          "right"
          "map"
          "pos";
        justify-items: center;
      }

      .joystick-container {
        width: 160px;
        height: 160px;
      }

      .image-view {
        width: 100%;
        max-width: 520px;
        height: auto;
      }

      .position-display,
      .map-display {
        width: 100%;
        max-width: 520px;
      }
    }
  </style>
</head>

<body>
  <div class="connection-form">
    <label for="robotNumber">Robot:</label>
    <input id="robotNumber" type="number" min="1" max="9" value="1" title="Robot number"/>
    <button id="connectBtn" onclick="connectToROS()">Connect</button>
  </div>

  <div class="dashboard">
    <img class="image-view" id="camera-feed" alt="Camera Feed" />

    <aside class="right-panel">
      <div class="joy-legend">Joystick</div>
      <div class="joystick-container" id="joystick_h"></div>

      <div class="joy-vel">
        vₓ: <span id="vx">0.00</span> m/s · vᵧ: <span id="vy">0.00</span> m/s
      </div>

      <div class="omega-wrap">
        <label for="omegaSlider">ω:</label>
        <input id="omegaSlider" type="range" min="-1" max="1" step="0.01" value="0" />
        <span id="omegaVal">0.00</span> rad/s
      </div>
    </aside>

    <div class="map-display">
      <h3>Map + LiDAR</h3>
      <canvas id="map-canvas" class="map-image" width="200" height="200"></canvas>
    </div>

    <div class="position-display">
      <h3>Position & Orientation</h3>
      <p>X (m): <span id="position-x">0</span></p>
      <p>Y (m): <span id="position-y">0</span></p>
      <p>&Theta; (º): <span id="rotation-z">0</span></p>
    </div>
  </div>

  <script>
    let ros;
    let cmdVelTopic;

    const MAP_RESOLUTION = 0.01;   // m/px
    const ROBOT_LEN = 0.30;        // 30cm (X forward)
    const ROBOT_WID = 0.20;        // 20cm (Y lateral)
    const SPEED_VECTOR_GAIN = 0.5; // metres de fletxa per (m/s)
    const maxSpeed = 0.3;
    const maxTurn  = 0.4;
    const distanceFactor = 75;

    let currentLinearX = 0;
    let currentLinearY = 0;
    let currentAngularZ = 0;

    let mapImage = new Image();
    let latestScan = null;

    let odomCenterSet = false;
    let odomCenterX = 0;
    let odomCenterY = 0;

    let yawOffsetSet = false;
    let yawOffset = 0;
    let cosYaw0 = 1;
    let sinYaw0 = 0;

    // Pose en frame display (+X amunt, +Y dreta)
    let lastRobotX = 0;
    let lastRobotY = 0;
    let lastRobotYaw = 0; // yaw relatiu en frame món (no invertit)

    function getRosbridgeAddress() {
      const currentUrl = window.location.href;
      const rosbridgeUrl = currentUrl.replace(/\/webpage\/?$/, '/rosbridge/');
      return rosbridgeUrl.replace(/^http/, 'ws').replace(/^https/, 'wss');
    }

    function quaternionToYaw(q) {
      const siny_cosp = 2 * (q.w * q.z + q.x * q.y);
      const cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
      return Math.atan2(siny_cosp, cosy_cosp);
    }

    function connectToROS() {
      if (ros && ros.isConnected) return;

      document.getElementById('connectBtn')?.setAttribute('disabled', 'disabled');
      const robotNum = parseInt(document.getElementById('robotNumber').value) || 1;

      const mapName = "map";
      const mapPath = `maps/${mapName}.png`;

      const host = window.location.hostname;
      const scheme = location.protocol === 'https:' ? 'wss' : 'ws';

      let rosbridgeAddress;
      if (host.startsWith("192.168.1.")) {
        const lastOctet = robotNum * 10 + 4;
        const robotHost = `192.168.1.${lastOctet}`;
        rosbridgeAddress = `${scheme}://${robotHost}:9090`;
      } else {
        rosbridgeAddress = getRosbridgeAddress();
      }
      console.log("Connecting to:", rosbridgeAddress);

      resizeMapCanvas();
      mapImage.onload = () => resizeMapCanvas();
      mapImage.src = mapPath;

      ros = new ROSLIB.Ros({ url: rosbridgeAddress });

      const connectBtn = document.getElementById('connectBtn');
      ros.on('connection', () => {
        console.log('Connected');
        connectBtn?.classList.add('connected');
        connectBtn?.removeAttribute('disabled');
        ros.isConnected = true;
        setupTopics();
        setupControls();
      });

      ros.on('error', (e) => {
        console.error('Connection Error:', e);
        connectBtn?.classList.remove('connected');
        connectBtn?.removeAttribute('disabled');
        ros.isConnected = false;
      });

      ros.on('close', () => {
        console.log('Connection closed.');
        connectBtn?.classList.remove('connected');
        connectBtn?.removeAttribute('disabled');
        ros.isConnected = false;
      });
    }

    function setupTopics() {
      cmdVelTopic = new ROSLIB.Topic({
        ros,
        name: '/cmd_vel',
        messageType: 'geometry_msgs/msg/Twist'
      });

      const imageTopic = new ROSLIB.Topic({
        ros,
        name: '/image_raw/compressed',
        messageType: 'sensor_msgs/msg/CompressedImage'
      });
      imageTopic.subscribe(msg => {
        document.getElementById('camera-feed').src =
          "data:image/jpeg;base64," + msg.data;
      });

      const odomTopic = new ROSLIB.Topic({
        ros,
        name: '/odom',
        messageType: 'nav_msgs/msg/Odometry'
      });
      odomTopic.subscribe(msg => {
        const p = msg.pose.pose.position;
        const o = msg.pose.pose.orientation;
        const t = msg.twist.twist;

        const yawAbs = quaternionToYaw(o);

        if (!odomCenterSet) {
          odomCenterX = p.x;
          odomCenterY = p.y;
          odomCenterSet = true;
        }

        if (!yawOffsetSet) {
          yawOffset = yawAbs;
          cosYaw0 = Math.cos(yawOffset);
          sinYaw0 = Math.sin(yawOffset);
          yawOffsetSet = true;
        }

        const yawRel = yawAbs - yawOffset;
        lastRobotYaw = yawRel; // per càlculs de món/LiDAR

        const dx = p.x - odomCenterX;
        const dy = p.y - odomCenterY;

        // Frame inicial: X_rel (forward inicial), Y_left_rel (esquerra inicial)
        const X_rel =  cosYaw0 * dx + sinYaw0 * dy;
        const Y_left_rel = -sinYaw0 * dx + cosYaw0 * dy;

        // Display: +X amunt, +Y dreta
        lastRobotX = X_rel;
        lastRobotY = -Y_left_rel;

        document.getElementById('position-x').textContent = lastRobotX.toFixed(2);
        document.getElementById('position-y').textContent = lastRobotY.toFixed(2);
        document.getElementById('rotation-z').textContent =
          (lastRobotYaw * 180 / Math.PI).toFixed(1);

        // Velocitat base_link
        const vx_b = t.linear.x;
        const vy_b = t.linear.y;

        const c = Math.cos(yawRel);
        const s = Math.sin(yawRel);

        // Globals en frame inicial
        const vx_rel = vx_b * c - vy_b * s;
        const vy_left_rel = vx_b * s + vy_b * c;

        const vx_disp = vx_rel;
        const vy_disp = -vy_left_rel;

        drawRobotState(lastRobotX, lastRobotY,
                       vx_disp, vy_disp,
                       lastRobotYaw, latestScan);
      });

      const scanTopic = new ROSLIB.Topic({
        ros,
        name: '/scan',
        messageType: 'sensor_msgs/msg/LaserScan'
      });
      scanTopic.subscribe(msg => {
        latestScan = msg;
      });
    }

    function resizeMapCanvas() {
      const canvas = document.getElementById('map-canvas');
      if (!canvas) return;
      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth || canvas.width || 200;
      const cssH = canvas.clientHeight || canvas.height || cssW;
      canvas.width  = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // Frame display: +X amunt, +Y dreta
    function worldToPixel(x, y, W, H) {
      const px = W / 2 + (y / MAP_RESOLUTION);
      const py = H / 2 - (x / MAP_RESOLUTION);
      return [px, py];
    }

    function drawAxes(ctx, W, H) {
      const cx = W / 2;
      const cy = H / 2;
      const metersPerTick = 0.30;
      const pxPerMeter = 1.0 / MAP_RESOLUTION;
      const tickPx = metersPerTick * pxPerMeter;
      const tickLen = 5;

      ctx.save();

      // X vermell (vertical)
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(cx, 0);
      ctx.lineTo(cx, H);
      ctx.stroke();

      // Ticks X
      const maxXTicks = Math.floor((H / 2) / tickPx);
      for (let i = 1; i <= maxXTicks; i++) {
        const yUp = cy - i * tickPx;
        const yDn = cy + i * tickPx;
        ctx.beginPath(); ctx.moveTo(cx - tickLen, yUp); ctx.lineTo(cx + tickLen, yUp); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cx - tickLen, yDn); ctx.lineTo(cx + tickLen, yDn); ctx.stroke();
      }

      // Y verd (horitzontal)
      ctx.strokeStyle = 'green';
      ctx.beginPath();
      ctx.moveTo(0, cy);
      ctx.lineTo(W, cy);
      ctx.stroke();

      // Ticks Y
      const maxYTicks = Math.floor((W / 2) / tickPx);
      for (let i = 1; i <= maxYTicks; i++) {
        const xR = cx + i * tickPx;
        const xL = cx - i * tickPx;
        ctx.beginPath(); ctx.moveTo(xR, cy - tickLen); ctx.lineTo(xR, cy + tickLen); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(xL, cy - tickLen); ctx.lineTo(xL, cy + tickLen); ctx.stroke();
      }

      ctx.restore();
    }

    function drawRobotState(robotX, robotY, velX, velY, yawRel, scanMsg) {
      const canvas = document.getElementById('map-canvas');
      const ctx = canvas.getContext('2d');
      const W = canvas.clientWidth || canvas.width;
      const H = canvas.clientHeight || canvas.height;

      ctx.clearRect(0, 0, W, H);

      if (mapImage.complete && mapImage.naturalWidth > 0) {
        ctx.drawImage(mapImage, 0, 0, W, H);
      }

      drawAxes(ctx, W, H);

      // IMPORTANT: al canvas hem reflectit Y, així que l'angle de dibuix s'inverteix
      const yawDraw = -yawRel;

      // Precompute robot en frame inicial relatiu
      const X_rel = robotX;
      const Y_left_rel = -robotY;

      // ---- LiDAR (en món correcte, sense invertir) ----
      if (scanMsg && yawOffsetSet && odomCenterSet) {
        const angleMin = scanMsg.angle_min;
        const angleInc = scanMsg.angle_increment;
        const rangeMin = scanMsg.range_min;
        const rangeMax = scanMsg.range_max;
        const ranges = scanMsg.ranges || [];

        ctx.save();
        ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';

        for (let i = 0; i < ranges.length; i++) {
          const r = ranges[i];
          if (!isFinite(r) || r < rangeMin || r > rangeMax) continue;

          const a = angleMin + i * angleInc;

          // Punt en robot frame (X forward, Y left)
          const x_r = r * Math.cos(a);
          const y_r = r * Math.sin(a);

          const c = Math.cos(yawRel);
          const s = Math.sin(yawRel);

          // En frame inicial relatiu (no display)
          const Xp_rel = X_rel + c * x_r - s * y_r;
          const Yp_left_rel = Y_left_rel + s * x_r + c * y_r;

          // A display (+Y dreta)
          const Xd = Xp_rel;
          const Yd = -Yp_left_rel;

          const [px, py] = worldToPixel(Xd, Yd, W, H);
          if (px >= 0 && px <= W && py >= 0 && py <= H) {
            ctx.fillRect(px, py, 2, 2);
          }
        }

        ctx.restore();
      }

      // ---- Robot rectangle 30x20 cm ----
      const [cx, cy] = worldToPixel(robotX, robotY, W, H);
      const hx = ROBOT_LEN / 2;
      const hy = ROBOT_WID / 2;

      const corners = [
        [ hx,  hy],
        [ hx, -hy],
        [-hx, -hy],
        [-hx,  hy]
      ];

      ctx.save();
      ctx.beginPath();
      for (let i = 0; i < corners.length; i++) {
        const [xr, yr] = corners[i];
        const c = Math.cos(yawDraw);
        const s = Math.sin(yawDraw);
        const Xw = robotX + c * xr - s * yr;
        const Yw = robotY + s * xr + c * yr;
        const [px, py] = worldToPixel(Xw, Yw, W, H);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1.5;
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      // ---- Orientació (blava) amb yawDraw ----
      {
        const arrowLen = 0.20;
        const Xtip = robotX + Math.cos(yawDraw) * arrowLen;
        const Ytip = robotY + Math.sin(yawDraw) * arrowLen;
        const [ax, ay] = worldToPixel(Xtip, Ytip, W, H);
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(ax, ay);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'blue';
        ctx.stroke();
      }

      // ---- Vector velocitat (vermell) en coords display (ja correctes) ----
      const speed = Math.hypot(velX, velY);
      if (speed > 0.01) {
        const len_m = speed * SPEED_VECTOR_GAIN;
        const Xv = robotX + (velX / speed) * len_m;
        const Yv = robotY + (velY / speed) * len_m;
        const [vx_px, vy_px] = worldToPixel(Xv, Yv, W, H);

        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(vx_px, vy_px);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'red';
        ctx.stroke();

        const ang = Math.atan2(vy_px - cy, vx_px - cx);
        ctx.save();
        ctx.translate(vx_px, vy_px);
        ctx.rotate(ang);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-8, 4);
        ctx.lineTo(-8, -4);
        ctx.closePath();
        ctx.fillStyle = 'red';
        ctx.fill();
        ctx.restore();
      }
    }

    function publishTwist() {
      const mag = Math.hypot(currentLinearX, currentLinearY);
      let vx = currentLinearX;
      let vy = currentLinearY;
      if (mag > maxSpeed && mag > 0) {
        const s = maxSpeed / mag;
        vx *= s;
        vy *= s;
      }

      if (!cmdVelTopic) return;
      const twist = new ROSLIB.Message({
        linear:  { x: vx, y: vy, z: 0 },
        angular: { x: 0, y: 0, z: currentAngularZ }
      });
      cmdVelTopic.publish(twist);
    }

    function setupControls() {
      const j = nipplejs.create({
        zone: document.getElementById('joystick_h'),
        mode: 'static',
        position: { left: '50%', top: '50%' },
        color: 'red',
        size: 150
      });

      const vxSpan = document.getElementById('vx');
      const vySpan = document.getElementById('vy');
      const omegaSlider = document.getElementById('omegaSlider');
      const omegaVal = document.getElementById('omegaVal');

      j.on('move', (evt, data) => {
        const ratio = Math.min(data.distance / distanceFactor, 1.0);
        const a = data.angle.radian;
        currentLinearX = Math.sin(a) * maxSpeed * ratio;
        currentLinearY = -Math.cos(a) * maxSpeed * ratio;
        vxSpan.textContent = currentLinearX.toFixed(2);
        vySpan.textContent = currentLinearY.toFixed(2);
      });

      j.on('end', () => {
        currentLinearX = 0;
        currentLinearY = 0;
        vxSpan.textContent = '0.00';
        vySpan.textContent = '0.00';
      });

      // ω: esquerra (+), dreta (-)
      omegaSlider.addEventListener('input', () => {
        const v = parseFloat(omegaSlider.value) || 0;
        currentAngularZ = -v * maxTurn;
        omegaVal.textContent = currentAngularZ.toFixed(2);
      });

      setInterval(() => {
        publishTwist();
        omegaVal.textContent = currentAngularZ.toFixed(2);
      }, 50);
    }

    window.addEventListener('resize', resizeMapCanvas);
    window.addEventListener('DOMContentLoaded', () => {
      resizeMapCanvas();
      const robotInput = document.getElementById('robotNumber');
      robotInput.addEventListener('change', (e) => {
        let v = parseInt(e.target.value);
        if (v < 1) v = 1;
        if (v > 9) v = 9;
        e.target.value = v;
      });
    });
  </script>
</body>
</html>
