<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ROS Web Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/roslib@1/build/roslib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  <style>
    :root{
      --gap: 20px;
      --card-bg: #fff;
      --card-bd: #ccc;
      --page-bg: #414141;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--page-bg);
      color: #000;
    }

    .connection-form {
      width: 100%;
      margin-bottom: var(--gap);
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    .connection-form label { color: #fff; }
    .connection-form input[type="number"]{
      width: 70px;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #bbb;
      background: #fff;
    }
    .connection-form button{
      padding: 8px 14px;
      border-radius: 6px;
      border: 1px solid #bbb;
      background: #f5f5f5;
      cursor: pointer;
    }
    .connection-form button:hover { filter: brightness(0.97); }

    /* ======= LAYOUT (desktop/tablet) ======= */
    .dashboard {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      grid-template-areas:
        ".      camera joyR"
        ".      .      labR"
        ".      .      velR"
        ".      .      omegaR"
        "map    map    pos";
      align-items: center;
      justify-items: center;
      gap: var(--gap);
    }

    /* Assignacions d'√†rees */
    #camera-feed      { grid-area: camera; }
    .map-display      { grid-area: map; }
    .position-display { grid-area: pos; }
    #joystick_h       { grid-area: joyR; justify-self: start; }
    .joy-label-right  { grid-area: labR; }
    .joy-vel-right    { grid-area: velR; }
    .omega-wrap       { grid-area: omegaR; }

    /* Targetes / caixes */
    .position-display,
    .map-display {
      width: 200px;
      padding: 10px;
      background-color: var(--card-bg, #fff);
      border-radius: 5px;
      border: 1px solid var(--card-bd, #ccc);
      color: #111;
    }

    /* Mapa m√©s ample per√≤ responsiu */
    .map-display { width: min(360px, 100%); }

    /* Joystick */
    .joystick-container {
      width: 200px;
      height: 200px;
      background-color: #ddd;
      border-radius: 50%;
      position: relative;
      overflow: hidden;
      touch-action: none; /* evita scroll/zoom accidental al m√≤bil */
    }

    .joy-label {
      margin-top: 6px;
      font-size: 0.95rem;
      font-weight: 600;
      color: #eee;
      text-align: center;
    }

    .joy-vel {
      margin-top: 2px;
      font-size: 0.9rem;
      color: #ddd;
      text-align: center;
    }

    /* Control omega (slider) */
    .omega-wrap {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #eee;
      font-size: 0.95rem;
    }
    .omega-wrap input[type="range"] {
      width: 180px;
    }

    /* C√†mera */
    .image-view {
      width: 360px;
      height: 270px;
      background-color: #000;
      border-radius: 5px;
      border: 1px solid var(--card-bd);
      object-fit: cover;
      display: block;
    }

    /* Canvas mapa */
    .map-image {
      width: 100%;
      height: auto;
      border: 1px solid var(--card-bd);
      border-radius: 5px;
      display: block;
    }

    /* ======= Responsive (m√≤bil) ======= */
    @media (max-width: 900px) {
      .dashboard {
        grid-template-columns: 1fr;
        grid-template-areas:
          "camera"
          "joyR"
          "labR"
          "velR"
          "omegaR"
          "map"
          "pos";
        justify-items: center;
      }

      .joystick-container {
        width: 160px;
        height: 160px;
      }

      .image-view {
        width: 100%;
        max-width: 520px;
        height: auto; /* conserva proporci√≥ */
      }

      .position-display,
      .map-display {
        width: 100%;
        max-width: 520px;
      }
    }
  </style>
</head>

<body>
  <div class="connection-form">
    <label for="robotNumber">Robot:</label>
    <input id="robotNumber" type="number" min="1" max="9" value="1" title="Robot number"/>
    <button onclick="connectToROS()">Connect</button>
  </div>

  <div class="dashboard">
    <!-- C√†mera -->
    <img class="image-view" id="camera-feed" alt="Camera Feed" />

    <!-- Joystick dret (√∫nic) -->
    <div class="joystick-container" id="joystick_h"></div>
    <div class="joy-label joy-label-right">Omni (Vx + Vy)</div>
    <div class="joy-vel joy-vel-right">
      v‚Çì: <span id="vx">0.00</span> m/s ¬∑ v·µß: <span id="vy">0.00</span> m/s
    </div>

    <!-- Control d'œâz -->
    <div class="omega-wrap">
      <label for="omegaSlider">œâùìè:</label>
      <input id="omegaSlider" type="range" min="-1" max="1" step="0.01" value="0" />
      <span id="omegaVal">0.00</span> rad/s
    </div>

    <!-- Panell posici√≥/orientaci√≥ -->
    <div class="position-display">
      <h3>Position & Orientation</h3>
      <p>X (m): <span id="position-x">0</span></p>
      <p>Y (m): <span id="position-y">0</span></p>
      <p>&Theta; (¬∫): <span id="rotation-z">0</span></p>
    </div>

    <!-- Mapa -->
    <div class="map-display">
      <h3>Map</h3>
      <canvas id="map-canvas" class="map-image" width="200" height="200"></canvas>
    </div>
  </div>

  <script>
    let ros;
    let cmdVelTopic;

    // --- Configuraci√≥ ---
    const MAP_RESOLUTION = 0.05; // m/p√≠xel (escala del teu mapa)
    const ROBOT_RADIUS = 5;      // p√≠xels (al canvas)
    const SPEED_VECTOR_SCALE = 50; // p√≠xels per (m/s) per la fletxa de velocitat

    // L√≠mits (opci√≥ C)
    const maxSpeed = 0.3;  // m/s (per Vx i Vy, amb clamp vectorial)
    const maxTurn  = 0.4;  // rad/s (omega z)
    const distanceFactor = 75; // ‚âà radi del joystick (size:150px)

    // Estat de control
    let currentLinearX = 0;
    let currentLinearY = 0;
    let currentAngularZ = 0;

    let joystick_h;
    let mapImage = new Image();

    function getRosbridgeAddress() {
      const currentUrl = window.location.href;
      const rosbridgeUrl = currentUrl.replace(/\/webpage\/?$/, '/rosbridge/');
      const rosbridgeAddress = rosbridgeUrl.replace(/^http/, 'ws').replace(/^https/, 'wss');
      return rosbridgeAddress;
    }

    function connectToROS() {
      const robotNum = parseInt(document.getElementById('robotNumber').value) || 1;

      const mapName = "map"; // fem servir el mapa per defecte
      const mapPath = `maps/${mapName}.png`;

      const host = window.location.hostname;
      const scheme = location.protocol === 'https:' ? 'wss' : 'ws';

      let rosbridgeAddress;
      if (host.startsWith("192.168.1.")) {
        // ‚úÖ Constru√Øm la IP a partir del n√∫mero de robot: x4 (1‚Üí14, 2‚Üí24, ...)
        const lastOctet = robotNum * 10 + 4;
        const robotHost = `192.168.1.${lastOctet}`;
        rosbridgeAddress = `${scheme}://${robotHost}:9090`;
      } else {
        // ‚úÖ Cas general (servidor extern o domini)
        rosbridgeAddress = getRosbridgeAddress();
      }
      console.log("Connecting to:", rosbridgeAddress);

      // Canvas n√≠tid
      resizeMapCanvas();
      mapImage.onload = () => {
        resizeMapCanvas();
        console.log('Map image loaded & canvas resized.');
      };
      mapImage.src = mapPath;

      ros = new ROSLIB.Ros({ url: rosbridgeAddress });

      ros.on('connection', function () {
        console.log('Connected to rosbridge:', rosbridgeAddress);
        setupTopics();
        setupControls();
      });

      ros.on('error', function (error) {
        console.error('Connection Error:', error);
      });

      ros.on('close', function () {
        console.log('Connection closed.');
      });
    }

    function quaternionToYaw(orientation) {
      const q = orientation;
      const siny_cosp = 2 * (q.w * q.z + q.x * q.y);
      const cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
      return Math.atan2(siny_cosp, cosy_cosp); // rad
    }

    function setupTopics() {
      cmdVelTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/cmd_vel',
        messageType: 'geometry_msgs/Twist'
      });

      // C√†mera
      const imageTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/camera1/image_raw/compressed',
        messageType: 'sensor_msgs/CompressedImage'
      });
      imageTopic.subscribe(function (message) {
        document.getElementById('camera-feed').src = "data:image/jpeg;base64," + message.data;
      });

      // Odometria -> pose + dibuix mapa
      const odomTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/odom',
        messageType: 'nav_msgs/Odometry'
      });
      odomTopic.subscribe(function (message) {
        const position = message.pose.pose.position;
        const orientation = message.pose.pose.orientation;
        const twist = message.twist.twist;

        // Text posici√≥
        document.getElementById('position-x').textContent = position.x.toFixed(2);
        document.getElementById('position-y').textContent = position.y.toFixed(2);
        const yaw = quaternionToYaw(orientation);
        const yawDeg = yaw * 180 / Math.PI; // graus
        document.getElementById('rotation-z').textContent = yawDeg.toFixed(1);

        // Velocitat global (per vector dibuixat)
        const velX_robot = twist.linear.x;
        const velY_robot = twist.linear.y;
        const velX_global = velX_robot * Math.cos(yaw) - velY_robot * Math.sin(yaw);
        const velY_global = velX_robot * Math.sin(yaw) + velY_robot * Math.cos(yaw);

        drawRobotState(position.x, position.y, velX_global, velY_global, yaw);
      });
    }

    // ===== Canvas n√≠tid
    function resizeMapCanvas() {
      const canvas = document.getElementById('map-canvas');
      if (!canvas) return;

      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth;
      const cssH = canvas.clientHeight;

      canvas.width  = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);

      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function drawRobotState(robotX, robotY, velX, velY, yaw) {
      const canvas = document.getElementById('map-canvas');
      const ctx = canvas.getContext('2d');

      const W = canvas.clientWidth;
      const H = canvas.clientHeight;

      ctx.clearRect(0, 0, W, H);
      if (mapImage.complete) {
        ctx.drawImage(mapImage, 0, 0, W, H);
      }

      // (0,0) al centre del canvas
      const pixelX = robotX / MAP_RESOLUTION + W / 2;
      const pixelY = H / 2 - robotY / MAP_RESOLUTION;

      // Robot
      ctx.beginPath();
      ctx.arc(pixelX, pixelY, ROBOT_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = 'green';
      ctx.fill();
      ctx.strokeStyle = 'black';
      ctx.stroke();

      // Orientaci√≥
      const orientationLength = ROBOT_RADIUS * 1.5;
      const endYawX = pixelX + Math.cos(yaw) * orientationLength;
      const endYawY = pixelY - Math.sin(yaw) * orientationLength;
      ctx.beginPath();
      ctx.moveTo(pixelX, pixelY);
      ctx.lineTo(endYawX, endYawY);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'blue';
      ctx.stroke();

      // Vector velocitat global
      const speed = Math.hypot(velX, velY);
      if (speed > 0.01) {
        const movementAngle = Math.atan2(velY, velX);
        const vectorLength = speed * SPEED_VECTOR_SCALE;
        const endX = pixelX + Math.cos(movementAngle) * vectorLength;
        const endY = pixelY - Math.sin(movementAngle) * vectorLength;

        ctx.beginPath();
        ctx.moveTo(pixelX, pixelY);
        ctx.lineTo(endX, endY);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'red';
        ctx.stroke();

        // Fletxa
        ctx.fillStyle = 'red';
        ctx.save();
        ctx.translate(endX, endY);
        ctx.rotate(-movementAngle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-10, 5);
        ctx.lineTo(-10, -5);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }

    function publishTwist() {
      // Clamp vectorial per assegurar |v| ‚â§ maxSpeed
      const mag = Math.hypot(currentLinearX, currentLinearY);
      if (mag > maxSpeed && mag > 0) {
        const scale = maxSpeed / mag;
        currentLinearX *= scale;
        currentLinearY *= scale;
      }

      const twist = new ROSLIB.Message({
        linear:  { x: currentLinearX, y: currentLinearY, z: 0 },
        angular: { x: 0, y: 0, z: currentAngularZ }
      });
      if (cmdVelTopic) {
        cmdVelTopic.publish(twist);
      }
    }

    function setupControls() {
      // ===== Joystick dret (omni: Vx + Vy)
      const options_h = {
        zone: document.getElementById('joystick_h'),
        mode: 'static',
        position: { left: '50%', top: '50%' },
        color: 'red',
        size: 150
      };
      const j = nipplejs.create(options_h);

      j.on('move', function (evt, data) {
        const ratio = Math.min(data.distance / distanceFactor, 1.0);
        currentLinearX = Math.sin(data.angle.radian) * maxSpeed * ratio;
        currentLinearY = -Math.cos(data.angle.radian) * maxSpeed * ratio;

        // UI
        document.getElementById('vx').textContent = currentLinearX.toFixed(2);
        document.getElementById('vy').textContent = currentLinearY.toFixed(2);
      });

      j.on('end', function () {
        currentLinearX = 0;
        currentLinearY = 0;
        document.getElementById('vx').textContent = '0.00';
        document.getElementById('vy').textContent = '0.00';
      });

      // ===== Slider omega (œâz)
      const omegaSlider = document.getElementById('omegaSlider');
      const omegaVal = document.getElementById('omegaVal');
      if (omegaSlider) {
        omegaSlider.addEventListener('input', () => {
          currentAngularZ = parseFloat(omegaSlider.value) * maxTurn;
          omegaVal.textContent = currentAngularZ.toFixed(2);
        });
      }

      // ===== Publicaci√≥ a freq fixa (~20 Hz) + refresc œâz
      setInterval(() => {
        publishTwist();
        document.getElementById('omegaVal').textContent = currentAngularZ.toFixed(2);
      }, 50);
    }

    window.addEventListener('resize', resizeMapCanvas);

    // Validaci√≥ simple del rang del robot 1..9
    window.addEventListener('DOMContentLoaded', () => {
      const robotInput = document.getElementById('robotNumber');
      robotInput.addEventListener('change', (e) => {
        let v = parseInt(e.target.value);
        if (v < 1) v = 1;
        if (v > 9) v = 9;
        e.target.value = v;
      });
    });
  </script>
</body>
</html>
